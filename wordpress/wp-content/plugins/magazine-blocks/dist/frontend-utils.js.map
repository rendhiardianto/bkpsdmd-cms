{"version":3,"file":"frontend-utils.js","mappings":"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","sources":["webpack://magazineBlocksUtils/webpack/universalModuleDefinition","webpack://magazineBlocksUtils/webpack/bootstrap","webpack://magazineBlocksUtils/webpack/runtime/define property getters","webpack://magazineBlocksUtils/webpack/runtime/hasOwnProperty shorthand","webpack://magazineBlocksUtils/webpack/runtime/make namespace object","webpack://magazineBlocksUtils/./src/frontend/utils/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"magazineBlocksUtils\"] = factory();\n\telse\n\t\troot[\"magazineBlocksUtils\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Selects the first element that matches the given CSS selector.\n *\n * @function $\n * @param {string} selector - A CSS selector string used to select an element.\n * @returns {Element | null} - The first element that matches the selector, or null if no matches are found.\n * @throws {DOMException} Will throw a DOMException if the provided selector is invalid.\n *\n * @example\n * // Select the first paragraph on the page\n * const firstParagraph = $('.paragraph');\n *\n * // Select the first anchor tag within a specific div\n * const firstAnchorInDiv = $('#myDiv a');\n */\nexport const $ = document.querySelector.bind(document);\n\n/**\n * Selects and returns a list of elements that match the given CSS selector.\n *\n * @function $$\n * @param {string} selector - A CSS selector string used to select elements.\n * @returns {NodeList} - A NodeList containing the selected elements.\n * @throws {DOMException} Will throw a DOMException if the provided selector is invalid.\n *\n * @example\n * // Select all paragraphs on the page\n * const paragraphs = $$('.paragraph');\n *\n * // Select all anchor tags within a specific div\n * const anchorsInDiv = $$('#myDiv a');\n */\nexport const $$ = document.querySelectorAll.bind(document);\n\n/**\n * Executes a callback function when the DOM is ready.\n *\n * @function domReady\n * @param {() => void} callback - The callback function to be executed when the DOM is ready.\n *\n * @example\n * // Usage example:\n * domReady(() => {\n *   // Your code that depends on the DOM being ready goes here\n *   console.log('DOM is ready!');\n * });\n */\nexport const domReady = (callback: () => void) => {\n\tif (\n\t\tdocument.readyState === \"complete\" ||\n\t\tdocument.readyState === \"interactive\"\n\t) {\n\t\tcallback();\n\t} else {\n\t\tdocument.addEventListener(\"DOMContentLoaded\", callback);\n\t}\n};\n\n/**\n * Returns an array of sibling elements of the given HTML element.\n *\n * @function siblings\n * @param {HTMLElement|string} elementOrSelector - The HTML element or selector whose siblings are to be retrieved.\n * @returns {HTMLElement[]} - An array containing the sibling elements.\n *\n * @example\n * // Usage example:\n * const myElement = document.getElementById('myElement');\n * const siblingElements = siblings(myElement);\n * console.log(siblingElements); // Array of sibling elements\n */\nexport const siblings = (elementOrSelector: HTMLElement | string) => {\n\tconst el =\n\t\ttypeof elementOrSelector === \"string\"\n\t\t\t? $(elementOrSelector)\n\t\t\t: elementOrSelector;\n\treturn Array.from(el?.parentElement?.children ?? []).filter(\n\t\t(sibling) => sibling !== el\n\t) as HTMLElement[];\n};\n\n/**\n * Observes an element to detect when it becomes visible in the viewport and invokes a callback.\n *\n * @function observeElementInView\n * @param {Element} element - The HTML element to observe for visibility changes.\n * @param {(...args: any[]) => void} onElementInView - The callback function to be invoked when the element is in view.\n *   @param {...any} args - Additional arguments to be passed to the callback function.\n *\n * @example\n * // Usage example:\n * const myElement = document.getElementById('myElement');\n * observeElementInView(myElement, (targetElement, originalElement) => {\n *   // Your code to handle the visibility of the element goes here\n *   console.log('Element is in view:', targetElement);\n *   console.log('Original element:', originalElement);\n * });\n */\nexport const observeElementInView = (\n\telement: Element,\n\tonElementInView: (...args: any[]) => void\n) => {\n\tconst observer = new IntersectionObserver(\n\t\t(entries) => {\n\t\t\tentries.forEach((entry) => {\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\tonElementInView(entry.target, element);\n\t\t\t\t\tobserver.disconnect();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t{\n\t\t\troot: document, // Use the viewport as the root\n\t\t\tthreshold: 0.5, // 50% of the element is in view\n\t\t}\n\t);\n\tobserver.observe(element);\n};\n\n/**\n * Parses a string of HTML and returns the resulting HTML element or document fragment.\n *\n * @function parseHTML\n * @param {string} val - The string containing the HTML to be parsed.\n * @param {number} [depth=0] - The depth of the node to retrieve from the parsed HTML. Default is 0.\n * @returns {HTMLElement | DocumentFragment} - The HTML element or document fragment parsed from the input string.\n *\n * @example\n * // Usage example:\n * const htmlString = '<div><p>Hello, <strong>world!</strong></p></div>';\n * const parsedElement = parseHTML(htmlString);\n * document.body.appendChild(parsedElement); // Append the parsed element to the document body\n */\nexport const parseHTML = (val: string, depth: number = 0) => {\n\tconst parser = new DOMParser();\n\tconst doc = parser.parseFromString(val, \"text/html\");\n\tlet node = doc.body;\n\twhile (depth > 0) {\n\t\tdepth--;\n\t\t// @ts-ignore\n\t\tnode = node.firstChild;\n\t}\n\tif (node === null) {\n\t\t// @ts-ignore\n\t\tnode = document.createDocumentFragment();\n\t}\n\treturn node;\n};\n\n/**\n * Finds and returns the first matching element within the specified context.\n *\n * @function find\n * @param {Element | Document | string} eltOrSelector - The context within which to search for the element, or a CSS selector if no context is provided.\n * @param {string} [selector] - The CSS selector to match elements. If provided, the search is limited to the elements matching this selector.\n * @returns {Element | null} - The first matching element or null if no match is found.\n *\n * @example\n * // Usage example:\n * const myElement = find('#myId');\n * console.log(myElement); // The first element with the ID 'myId'\n */\nexport const find = (\n\teltOrSelector: Element | Document | string,\n\tselector?: string\n): Element | null => {\n\tif (selector) {\n\t\tif (typeof eltOrSelector === \"string\") {\n\t\t\treturn (\n\t\t\t\tdocument\n\t\t\t\t\t.querySelector(eltOrSelector)\n\t\t\t\t\t?.querySelector(selector) ?? null\n\t\t\t);\n\t\t} else {\n\t\t\treturn eltOrSelector.querySelector(selector);\n\t\t}\n\t} else {\n\t\treturn find(document, eltOrSelector as string);\n\t}\n};\n\n/**\n * Finds and returns all elements matching the specified selector within the specified context.\n *\n * @function findAll\n * @param {Document | Element | string} eltOrSelector - The context within which to search for the elements, or a CSS selector if no context is provided.\n * @param {string} [selector] - The CSS selector to match elements. If provided, the search is limited to the elements matching this selector.\n * @returns {NodeListOf<Element>} - A NodeList containing all matching elements.\n *\n * @example\n * // Usage example:\n * const allParagraphs = findAll('p');\n * console.log(allParagraphs); // NodeList of all <p> elements in the document\n */\nexport const findAll = (\n\teltOrSelector: Document | Element | string,\n\tselector?: string\n): NodeListOf<Element> => {\n\tif (selector) {\n\t\tif (typeof eltOrSelector === \"string\") {\n\t\t\treturn document.querySelectorAll(eltOrSelector);\n\t\t} else {\n\t\t\treturn eltOrSelector.querySelectorAll(selector);\n\t\t}\n\t} else {\n\t\treturn findAll(document, eltOrSelector as string);\n\t}\n};\n\n/**\n * Converts an array-like object to a real array.\n *\n * @param arrayLike - The array-like object to convert.\n * @returns An array containing the elements of the array-like object.\n * @template T - The type of elements in the array.\n * @example\n * const nodeList = document.querySelectorAll('.some-elements');\n * const elementArray = toArray(nodeList);\n */\nexport const toArray = <T>(arrayLike: ArrayLike<T>): T[] => {\n\treturn Array.prototype.slice.call(arrayLike);\n};\n\nexport const each = <T extends Collection>(\n\tcollection: T,\n\tcallbackfn: CallbackFn<T>\n) => {\n\tif (Array.isArray(collection)) {\n\t\tfor (let i = 0; i < collection.length; i++) {\n\t\t\tcallbackfn(collection[i], i);\n\t\t}\n\t} else {\n\t\tfor (let key in collection) {\n\t\t\t(callbackfn as ObjectCallbackFn<T>)(collection[key], key);\n\t\t}\n\t}\n};\n\ntype Collection = any[] | Record<any, any>;\ntype ArrayCallbackFn<T> = (value: T, index?: number) => void;\ntype ObjectCallbackFn<T> = <U extends keyof T>(value: T[U], key?: U) => void;\n\ntype CallbackFn<T> = T extends any[]\n\t? ArrayCallbackFn<T[number]>\n\t: T extends Record<string, any>\n\t? ObjectCallbackFn<T>\n\t: never;\n\n/**\n * Adds an event listener to one or more HTML elements.\n *\n * @param event - The type of event to listen for.\n * @param elementOrCollectionOfElement - The HTML element or an array of HTML elements to attach the event listener to.\n * @param callback - The callback function or event listener object to be executed when the event occurs.\n * @param options - An optional parameter to specify options for the event listener.\n *                  For example, `{ capture: true }`.\n *\n * @template K - The type parameter representing the valid event types.\n *\n * @remarks\n * If `elementOrCollectionOfElement` is an array, the event listener will be added to each element in the array.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/Events|List of DOM events}\n *\n * @example\n * // Single element\n * const myButton = document.getElementById('myButton') as HTMLElement;\n * if (myButton) {\n *   on('click', myButton, (event) => {\n *     // Handle click event on a single element\n *   });\n * }\n *\n * // Multiple elements\n * const buttons = document.querySelectorAll('.button') as NodeListOf<HTMLElement>;\n * on('click', buttons, (event) => {\n *   // Handle click event on each element in the collection\n * });\n */\nexport const on = <K extends keyof HTMLElementEventMap>(\n\tevent: K,\n\telementOrCollectionOfElement: HTMLElement | Array<HTMLElement> | null,\n\tcallback: EventListenerOrEventListenerObject,\n\toptions?: boolean | AddEventListenerOptions\n) => {\n\tif (!elementOrCollectionOfElement) return;\n\tif (Array.isArray(elementOrCollectionOfElement)) {\n\t\teach(elementOrCollectionOfElement, (element) =>\n\t\t\telement.addEventListener(event, callback, options)\n\t\t);\n\t\treturn;\n\t}\n\telementOrCollectionOfElement.addEventListener(event, callback, options);\n};\n\n/**\n * Retrieves the value of a cookie by its name.\n *\n * @param name - The name of the cookie to retrieve.\n * @returns The value of the cookie if found, or `null` if the cookie is not present.\n *\n * @remarks\n * This function searches for the specified cookie name in the `document.cookie` string.\n *\n * @example\n * const username = getCookie('username');\n * if (username) {\n *   console.log(`Welcome back, ${username}!`);\n * } else {\n *   console.log('Cookie not found.');\n * }\n */\nexport const getCookie = (name: string) => {\n\tconst cookies = document.cookie.split(\";\");\n\tfor (let i = 0; i < cookies.length; i++) {\n\t\tconst cookie = cookies[i].trim();\n\t\tif (cookie.startsWith(name + \"=\")) {\n\t\t\treturn cookie.substring(name.length + 1);\n\t\t}\n\t}\n\treturn null;\n};\n\n/**\n * Sets a cookie with the specified name, value, and expiration days.\n *\n * @param name - The name of the cookie to set.\n * @param value - The value to assign to the cookie.\n * @param expirationDays - The number of days until the cookie expires.\n *\n * @remarks\n * This function sets a cookie in the browser with the provided name, value, and expiration days.\n *\n * @example\n * setCookie('username', 'JohnDoe', 7);\n * // Sets a cookie named 'username' with the value 'JohnDoe' that expires in 7 days.\n */\nexport const setCookie = (\n\tname: string,\n\tvalue: string,\n\texpirationDays: number\n) => {\n\tconst expires = new Date();\n\texpires.setTime(expires.getTime() + expirationDays * 24 * 60 * 60 * 1000);\n\tdocument.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;\n};\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","$","document","querySelector","bind","$$","querySelectorAll","domReady","callback","readyState","addEventListener","siblings","elementOrSelector","_el$parentElement$chi","el","Array","from","parentElement","children","filter","sibling","observeElementInView","element","onElementInView","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","disconnect","threshold","observe","parseHTML","val","depth","node","DOMParser","parseFromString","body","firstChild","createDocumentFragment","find","eltOrSelector","selector","_document$querySelect","findAll","toArray","arrayLike","slice","each","collection","callbackfn","isArray","i","length","on","event","elementOrCollectionOfElement","options","getCookie","name","cookies","cookie","split","trim","startsWith","substring","setCookie","expirationDays","expires","Date","setTime","getTime","toUTCString"],"sourceRoot":""}